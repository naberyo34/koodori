/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function() {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nlet initialized = false;\nlet audioCtx;\nlet masterGainNode;\nlet biquadFilterNode;\nlet kickNode;\nlet snareNode;\nlet hihatNode;\nlet worker;\nlet currentNote = 0;\nlet nextNoteTime = 0;\nlet currentWaveform = 'sawtooth';\nlet currentFilter = 'lowpass';\nlet filterFrequency = 20000; // 20000 ~ 20\nlet filterQ = 0;\nlet noteLength = 8;\nlet noteGain = [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8];\nlet phrase = [\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n    'c3',\n];\nlet active = [\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n    true,\n];\nlet kick = [\n    true,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n];\nlet snare = [\n    false,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n];\nlet hihat = [\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n    true,\n    false,\n    false,\n    false,\n    true,\n    false,\n];\nlet bpm = 128;\n/**\n * 音名を周波数に変換して返す\n * @param pitchName 音名 (c3 - c4)\n * @returns 周波数\n */\nconst pitchNameToFrequency = (pitchName) => {\n    const table = {\n        c3: 130.813,\n        d3: 146.832,\n        e3: 164.814,\n        f3: 174.614,\n        g3: 195.998,\n        a3: 220,\n        b3: 246.942,\n        c4: 261.626,\n        d4: 293.665,\n        e4: 329.628,\n        f4: 349.228,\n        g4: 391.995,\n        a4: 440,\n        b4: 493.883,\n    };\n    return table[pitchName];\n};\n/**\n * 次に鳴る音を作成し、再生を予約する\n * @param time 次の発音時間\n * @param noteOption 鳴らす音の詳細設定\n */\nconst scheduleNote = (time, noteOption) => {\n    if (!active[currentNote])\n        return;\n    const { waveform, gain, pitchName, length } = noteOption;\n    const oscNode = new OscillatorNode(audioCtx, { type: waveform });\n    const noteGainNode = new GainNode(audioCtx, { gain });\n    oscNode.frequency.value = pitchNameToFrequency(pitchName);\n    oscNode.connect(noteGainNode);\n    noteGainNode.connect(biquadFilterNode);\n    oscNode.start(time);\n    oscNode.stop(time + length);\n};\n/**\n * BPMから次の発音時間を算出する\n */\nconst getNextNoteTime = () => {\n    const secondsPerBeat = 60 / bpm;\n    const noteTime = secondsPerBeat * 0.25;\n    nextNoteTime += noteTime;\n};\n/**\n * 発音のカウントを進める\n */\nconst stepNextNote = () => {\n    currentNote += 1;\n    if (currentNote === 16) {\n        currentNote = 0;\n    }\n};\n/**\n * 直近の発音を予約する\n */\nconst scheduler = () => {\n    const scheduleAheadTime = 0.1;\n    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {\n        const secondsPerBeat = 60 / bpm;\n        const noteTime = secondsPerBeat * 0.25;\n        scheduleNote(nextNoteTime, {\n            waveform: currentWaveform,\n            gain: noteGain[currentNote] * 0.1,\n            pitchName: phrase[currentNote],\n            length: noteTime * noteLength * 0.1,\n        });\n        getNextNoteTime();\n        stepNextNote();\n    }\n};\nconst setupSample = (samplePath) => __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield fetch(samplePath);\n    const arrayBuffer = yield response.arrayBuffer();\n    const audioBuffer = yield audioCtx.decodeAudioData(arrayBuffer);\n    return audioBuffer;\n});\nconst handleInitialize = () => __awaiter(void 0, void 0, void 0, function* () {\n    const lookahead = 25.0;\n    const kickSample = yield setupSample('assets/kick.wav');\n    const snareSample = yield setupSample('assets/kick.wav');\n    const hihatSample = yield setupSample('assets/kick.wav');\n    audioCtx = new AudioContext();\n    masterGainNode = new GainNode(audioCtx);\n    biquadFilterNode = new BiquadFilterNode(audioCtx, {\n        type: currentFilter,\n        frequency: filterFrequency,\n        Q: filterQ,\n    });\n    worker = new Worker('audioworker.js');\n    biquadFilterNode.connect(masterGainNode);\n    masterGainNode.connect(audioCtx.destination);\n    worker.onmessage = (e) => {\n        if (e.data === 'tick') {\n            scheduler();\n        }\n    };\n    worker.postMessage({ interval: lookahead });\n    initialized = true;\n});\nconst handleStart = () => {\n    currentNote = 0;\n    nextNoteTime = audioCtx.currentTime;\n    worker.postMessage('start');\n};\nconst handleStop = () => {\n    worker.postMessage('stop');\n};\nconst handleChangeWaveform = (e) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = e.currentTarget.value;\n    currentWaveform = value;\n};\nconst handleChangeBpm = (e) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = Number(e.currentTarget.value);\n    if (value < 1 || value > 999) {\n        alert('無効な値です。BPMは1 ~ 999の範囲で指定してください');\n        return;\n    }\n    bpm = value;\n};\nconst handleChangeNoteLength = (e) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = Number(e.currentTarget.value);\n    if (value < 0 || value > 10) {\n        alert('無効な値です。');\n    }\n    noteLength = value;\n};\nconst handleChangeFilterFrequency = (e) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = Number(e.currentTarget.value);\n    if (value < 20 || value > 20000) {\n        alert('無効な値です。');\n    }\n    filterFrequency = value;\n    biquadFilterNode.frequency.value = filterFrequency;\n};\nconst handleChangeFilterQ = (e) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = Number(e.currentTarget.value);\n    if (value < 0 || value > 30) {\n        alert('無効な値です。');\n    }\n    filterQ = value;\n    biquadFilterNode.Q.value = filterQ;\n};\nconst handleChangeNoteGain = (e, index) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = Number(e.currentTarget.value);\n    if (value < 0 || value > 10) {\n        alert('無効な値です。');\n    }\n    noteGain[index] = value;\n};\nconst handleChangePhrase = (e, index) => {\n    if (!(e.currentTarget instanceof HTMLSelectElement))\n        return;\n    const value = e.currentTarget.value;\n    phrase[index] = value;\n};\nconst handleChangeActive = (e, index) => {\n    if (!(e.currentTarget instanceof HTMLInputElement))\n        return;\n    const value = e.currentTarget.checked;\n    active[index] = value;\n};\nconst initializeButton = document.querySelector('[data-selector=initializeButton]');\nconst startButton = document.querySelector('[data-selector=startButton]');\nconst stopButton = document.querySelector('[data-selector=stopButton]');\nconst waveformSelects = document.querySelectorAll('[data-selector=waveformSelect]');\nconst bpmInput = document.querySelector('[data-selector=bpmInput]');\nconst noteLengthInput = document.querySelector('[data-selector=noteLengthInput]');\nconst filterFrequencyInput = document.querySelector('[data-selector=filterFrequencyInput]');\nconst filterQInput = document.querySelector('[data-selector=filterQInput]');\nconst noteSelects = document.querySelectorAll('[data-selector=noteSelect]');\nconst activeSelects = document.querySelectorAll('[data-selector=activeSelect]');\nconst noteGainInputs = document.querySelectorAll('[data-selector=noteGainInput]');\ninitializeButton === null || initializeButton === void 0 ? void 0 : initializeButton.addEventListener('click', handleInitialize);\nstartButton === null || startButton === void 0 ? void 0 : startButton.addEventListener('click', handleStart);\nstopButton === null || stopButton === void 0 ? void 0 : stopButton.addEventListener('click', handleStop);\nwaveformSelects.forEach((waveformSelect) => {\n    waveformSelect.addEventListener('change', handleChangeWaveform);\n});\nbpmInput === null || bpmInput === void 0 ? void 0 : bpmInput.addEventListener('input', handleChangeBpm);\nnoteLengthInput === null || noteLengthInput === void 0 ? void 0 : noteLengthInput.addEventListener('input', handleChangeNoteLength);\nfilterFrequencyInput === null || filterFrequencyInput === void 0 ? void 0 : filterFrequencyInput.addEventListener('input', handleChangeFilterFrequency);\nfilterQInput === null || filterQInput === void 0 ? void 0 : filterQInput.addEventListener('input', handleChangeFilterQ);\nnoteSelects.forEach((noteSelect, index) => {\n    noteSelect.addEventListener('change', (e) => handleChangePhrase(e, index));\n});\nactiveSelects.forEach((activeSelect, index) => {\n    activeSelect.addEventListener('change', (e) => handleChangeActive(e, index));\n});\nnoteGainInputs.forEach((noteGainInput, index) => {\n    noteGainInput.addEventListener('input', (e) => handleChangeNoteGain(e, index));\n});\n\n\n//# sourceURL=webpack://koodori/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/main.ts"]();
/******/ 	
/******/ })()
;